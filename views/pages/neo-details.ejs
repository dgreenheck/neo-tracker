<!DOCTYPE html>
<html>
<head>
    <title><%= name %></title>
    <link rel="stylesheet" href="/css/styles.css" type="text/css">
    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.143.0/build/three.module.js"
        }
      }
    </script>
    <script type="text/javascript" src="/js/orbit.js"></script>
</head>
<body onload="filterTable()">
    <button onclick="history.back()">Back</button>

    <h1><%= name %></h1>

    <h2>Details</h2>
    <table>
      <tr>
        <td>Reference ID</td>
        <td><%= neo_reference_id %></td>
      </tr>
      <tr>
        <td>Designation</td>
        <td><%= designation %></td>
      </tr>
      <tr>
        <td>Absolute Magnitude</td>
        <td><%= absolute_magnitude_h %></td>
      </tr>
      <tr>
        <td>Is Potentially Hazardous</td>
        <td><%= is_potentially_hazardous_asteroid %></td>
      </tr>
      <tr>
        <td>Min Estimated Diameter (m)</td>
        <td><%= Math.round(estimated_diameter.meters.estimated_diameter_min).toLocaleString() %></td>
      </tr>
      <tr>
        <td>Max Estimated Diameter (m)</td>
        <td><%= Math.round(estimated_diameter.meters.estimated_diameter_max).toLocaleString() %></td>
      </tr>
    </table>

    <h2>Orbital Elements</h2>
    <table>
      <tr>
        <td>Eccentricity</td>
        <td><%= orbital_data.eccentricity %></td>
      </tr>
      <tr>
        <td>Semi-major Axis (AU)</td>
        <td><%= orbital_data.semi_major_axis %></td>
      </tr>
      <tr>
        <td>Inclination (deg)</td>
        <td><%= orbital_data.inclination %></td>
      </tr>
      <tr>
        <td>Longitude of the Ascending Node (deg)</td>
        <td><%= orbital_data.ascending_node_longitude %></td>
      </tr>
      <tr>
        <td>Argument of Perihelion</td>
        <td><%= orbital_data.perihelion_argument %></td>
      </tr>
      <tr>
        <td>Mean Anomaly</td>
        <td><%= orbital_data.mean_anomaly %></td>
      </tr>
      <tr>
        <td>Orbital Period (days)</td>
        <td><%= orbital_data.orbital_period %></td>
      </tr>
    </table>

    <div id="orbit-viewer"></div>

    <h2>Close Approaches</h2>
    
    <label for="start-date">Start Date: </label>
    <input type="date" id="start-date" onfocusout="filterTable()" value="1900-01-01" min="1900-01-01" max="2200-01-01">
    <label for="end-date">End Date: </label>
    <input type="date" id="end-date" onfocusout="filterTable()" value="2200-01-01" min="1900-01-01" max="2200-01-01">
    
    <table id="table-closest-approaches">
      <tr>
        <th style="display: none;"></th>
        <th class="bg-primary text-white align-left">Date</th>
        <th class="bg-primary text-white align-right">Miss Distance (km)</th>
        <th class="bg-primary text-white align-right">Relative Velocity (km/s)</th>
      </tr>
      <% close_approach_data.forEach(approach => { %>
      <tr>
        <%# Hide this column, only used for filtering %>
        <td style="display: none;"><%= approach.close_approach_date %></td>
        <td class="align-left"><%= approach.close_approach_date_full %></td>
        <td class="align-right"><%= Math.trunc(Number(approach.miss_distance.kilometers)).toLocaleString() %></td>
        <td class="align-right"><%= Number(approach.relative_velocity.kilometers_per_second).toFixed(3).toLocaleString() %></td>
      </tr>
      <% }) %>
    </table>
    
    <script type="text/javascript">
      function filterTable() {
        let startDate = Date.parse(document.getElementById("start-date").value);
        let endDate = Date.parse(document.getElementById("end-date").value);
        let table = document.getElementById("table-closest-approaches");
        let tableRows = table.getElementsByTagName("tr");

        // Loop through all table rows, and hide those who don't match the search query
        for (i = 0; i < tableRows.length; i++) {
          let dateColumn = tableRows[i].getElementsByTagName("td")[0];
          if (dateColumn) {
            let date = Date.parse(dateColumn.innerText);
            if (date >= startDate && date <= endDate) {
              tableRows[i].style.display = "";
            } else {
              tableRows[i].style.display = "none";
            }
          }
        }
      }

      function toggleStartDateFilter() {
        if (!document.getElementById('checkbox-start-date').checked) {
          document.getElementById('start-date').setAttribute('disabled', 'true');
        } else {
          document.getElementById('start-date').removeAttribute('disabled');
        }
      }

      function toggleEndDateFilter() {
        if (!document.getElementById('checkbox-end-date').checked) {
          document.getElementById('end-date').setAttribute('disabled', 'true');
        } else {
          document.getElementById('end-date').removeAttribute('disabled');
        }
      }
    </script>

    <script type="module">
      import * as THREE from 'three';
      import { OrbitControls } from 'https://unpkg.com/three@0.143.0/examples/jsm/controls/OrbitControls.js';

      // Setup renderer
      const renderer = new THREE.WebGLRenderer({ alpha: false });
      renderer.setClearColor(new THREE.Color( 0x000000 ), 1);
      renderer.setSize(600, 600);

      // Add canvas to the DOM
      let canvas = document.getElementById("orbit-viewer").appendChild(renderer.domElement);
      canvas.className = "view-three-d";

      // Setup scene
      const scene = new THREE.Scene();

      // Setup camera
      const camera = new THREE.PerspectiveCamera(75, 1.0, 0.1, 1000);
      camera.position.y = 40;
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
      controls.dampingFactor = 0.05;
      controls.screenSpacePanning = true;
      controls.minDistance = 1;
      controls.maxDistance = 100;
      controls.maxPolarAngle = Math.PI / 2;
      controls.update();

      const geometry = new THREE.SphereGeometry(1, 16, 16);
      const lineMaterial = new THREE.LineBasicMaterial( {color: 0x888888 });

      const sunMesh = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({ color: 0xffdd00 }));
      sunMesh.scale.set(0.25, 0.25, 0.25);
      scene.add(sunMesh);

      const t_eph = date2jd(Date.now());

      for (const [key, planet] of Object.entries(planets)) {
        addBodyToScene(planet, t_eph);
      }

      // Draw axes
      const xPoints = [new THREE.Vector3(0, 0, 0), new THREE.Vector3(1000, 0, 0)];
      const xAxis = new THREE.Line(new THREE.BufferGeometry().setFromPoints(xPoints),
                                   new THREE.LineBasicMaterial( {color: 0xFF0000 }));
      const yPoints = [new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 1000, 0)];
      const yAxis = new THREE.Line(new THREE.BufferGeometry().setFromPoints(yPoints),
                                   new THREE.LineBasicMaterial( {color: 0x00FF00 }));
      const zPoints = [new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 1000)];
      const zAxis = new THREE.Line(new THREE.BufferGeometry().setFromPoints(zPoints),
                                   new THREE.LineBasicMaterial( {color: 0x0000FF }));

      scene.add(xAxis);
      scene.add(yAxis);
      scene.add(zAxis);
      
      const neo = neoObject(t_eph);
      addBodyToScene(neo, t_eph);
      
      function addBodyToScene(body, t_eph) {

        // Create mesh for planet
        const planetMesh = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({ color: body.color }));
        const scale = Math.log10(body.diameter / 2) / 100.0;
        const pos = getBodyPosition(body, t_eph);
        planetMesh.scale.set(scale, scale, scale);
        planetMesh.position.set(pos.x, pos.y, pos.z);
        scene.add(planetMesh);

        // Create orbit
        const points = [];
        for (const p of getOrbitPoints(body, t_eph)) {
          points.push(new THREE.Vector3(p.x, p.y, p.z));
        }

        const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
        const line = new THREE.Line(lineGeometry, lineMaterial);
        scene.add(line);
      }

      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      };

      animate();

      function neoObject(t_eph) {
        const t_epoch = Number('<%= orbital_data.epoch_osculation %>');
        const a = Number('<%= orbital_data.semi_major_axis %>');
        const e = Number('<%= orbital_data.eccentricity %>');
        const I = Number('<%= orbital_data.inclination %>');
        const LAN = Number('<%= orbital_data.ascending_node_longitude %>');
        const arg_p = Number('<%= orbital_data.perihelion_argument %>');
        let M = Number('<%= orbital_data.mean_anomaly %>');
        const n = Number('<%= orbital_data.mean_motion %>');

        // Adjust mean anomaly by the mean motion to get the mean anomaly at t_eph
        M += (t_eph - t_epoch) * n;
        
        if (M < -180) M += 360;
        if (M > 180) M -= 360;

        // Adjust mean anomaly by the mean motion
        const LP = LAN + arg_p;
        const L = LAN + arg_p + M;

        return {
          diameter: 100,
          color: 0xFFFFFF,
          epoch: t_epoch,
          orbit: [a,e,I,L,LP,LAN,0,0,0,0,0,0]
        }
      }
      
    </script>
</body>
</html>